export type Iteratee = (value: any, key: string, collection: any) => any

export type Predicate<T> = (value: T, key: string) => boolean

export interface Dictionary<T> {
  [key: string]: T
}

/**
 * Check if the given array or object is empty.
 */
export function isEmpty (data: any[] | object): boolean {
  if (Array.isArray(data)) {
    return data.length === 0
  }

  return Object.keys(data).length === 0
}

/**
 * Iterates over own enumerable string keyed properties of an object and
 * invokes `iteratee` for each property.
 */
export function forOwn (object: any, iteratee: Iteratee): void {
  Object.keys(object).forEach(key => iteratee(object[key], key, object))
}

/**
 * Creates an object with the same keys as object and values generated by
 * running each own enumerable string keyed property of object thru
 * iteratee. The iteratee is invoked with three arguments:
 * (value, key, object).
 */
export function mapValues (object: any, iteratee: Iteratee): any {
  const newObject = Object.assign({}, object)

  return Object.keys(object).reduce((records, key) => {
    records[key] = iteratee(object[key], key, object)

    return records
  }, newObject)
}

/**
 * Creates an object composed of the object properties predicate returns
 * truthy for. The predicate is invoked with two arguments: (value, key).
 */
export function pickBy<T> (object: Dictionary<T>, predicate: Predicate<T>): Dictionary<T> {
  return Object.keys(object).reduce((records, key) => {
    const value = object[key]

    if (predicate(value, key)) {
      records[key] = value
    }

    return records
  }, {} as Dictionary<T>)
}

/**
 * Creates an array of elements, sorted in specified order by the results
 * of running each element in a collection thru each iteratee.
 */
export function orderBy<T> (collection: T[], keys: string[], directions: string[]): any {
  let index = -1

  const result = collection.map((value) => {
    const criteria = keys.map(key => value[key])

    return { criteria: criteria, index: ++index, value: value }
  })

  return baseSortBy(result, (object: any, other: any) => {
    return compareMultiple(object, other, directions)
  })
}

/**
 * Creates an object composed of keys generated from the results of running
 * each element of collection thru iteratee.
 */
export function groupBy (collection: any[], iteratee: (record: any) => any): any {
  return collection.reduce((records, record) => {
    const key = iteratee(record)

    if (records[key] === undefined) {
      records[key] = []
    }

    records[key].push(record)

    return records
  }, {} as any)
}

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their
 * corresponding values.
 */
function baseSortBy (array: any[], comparer: any): any[] {
  let length = array.length

  array.sort(comparer)

  while (length--) {
    array[length] = array[length].value
  }

  return array
}

/**
 * Used by `orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order.
 * Otherwise, specify an order of "desc" for descending or "asc" for
 * ascending sort order of corresponding values.
 */
function compareMultiple (object: any, other: any, orders: string[]): number {
  const objCriteria = object.criteria
  const othCriteria = other.criteria
  const length = objCriteria.length
  const ordersLength = orders.length

  let index = -1

  while (++index < length) {
    const result = compareAscending(objCriteria[index], othCriteria[index])

    if (result) {
      if (index >= ordersLength) {
        return result
      }

      const order = orders[index]

      return result * (order === 'desc' ? -1 : 1)
    }
  }

  return object.index - other.index
}

/**
 * Compares values to sort them in ascending order.
 */
function compareAscending (value: any, other: any): number {
  if (value !== other) {
    if (value > other) {
      return 1
    }

    if (value < other) {
      return -1
    }
  }

  return 0
}

/**
 * Takes values corresponding to keys in object and returns them concatenated with separator
 */
function concatValues (object: Object, keys: string[], separator = '_'): string {
  if (keys.length === 1) {
    // prevents casting value to String if the key is not a composite key
    return object[keys[0]]
  } else {
    return keys.map(k => object[k]).join(separator)
  }
}

/**
 * Returns value cast to Integer if value string contains only an integer, else returns value string as is
 */
function tryParseInt (value: string): string | number {
  if (parseInt(value, 10).toString() === value) {
    return parseInt(value, 10)
  } else {
    return value
  }
}

export default {
  isEmpty,
  forOwn,
  groupBy,
  mapValues,
  orderBy,
  pickBy,
  concatValues,
  tryParseInt
}
